{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Fireactions is an orchestrator for GitHub runners. BYOM (Bring Your Own Metal) and run self-hosted GitHub runners in ephemeral, fast and secure Firecracker based virtual machines.</p> <p></p> <p>Several key features:</p> <ul> <li>Autoscaling</li> </ul> <p>Robust pool based scaling, cost-effective with fast GitHub runner startup time of 20s~.</p> <ul> <li>Ephemeral</li> </ul> <p>Each virtual machine is created from scratch and destroyed after the job is finished, no state is preserved between jobs, just like with GitHub hosted runners.</p> <ul> <li>Customizable</li> </ul> <p>Define job labels and customize virtual machine resources to fit Your needs. See Configuration for more information.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#how-does-fireactions-compare-to-other-solutions","title":"How does Fireactions compare to other solutions?","text":"<p>Self hosted GitHub runners are a great way to run your CI/CD jobs on your own infrastructure. However, setting up and managing self-hosted runners can be a complex and time-consuming process. Fireactions aims to simplify this process by providing a lightweight and secure solution for orchestrating self-hosted GitHub runners.</p> <p>Compared to ARC(Actions Runner Controller), ARC is a Kubernetes operator with primary use case of managing self-hosted GitHub runners in Kubernetes clusters, while Fireactions is a standalone application that can be run on any regular bare metal server or a VM that supports nested virtualization.</p> <p>Kubernetes can be an overkill for most situations and managing a Kubernetes cluster can be complex and resource intensive task.</p>"},{"location":"faq/#do-i-need-to-use-a-bare-metal-server-or-a-vm-to-run-fireactions","title":"Do I need to use a bare metal server or a VM to run Fireactions?","text":"<p>Fireactions can be run on any regular bare metal server or a VM that supports nested virtualization. Do note that running Fireactions on a VM might have performance implications, especially if you are running multiple concurrent jobs.</p>"},{"location":"faq/#is-there-gpu-support-in-fireactions","title":"Is there GPU support in Fireactions?","text":"<p>Currently, Fireactions does not support GPU workloads. Fireactions uses Firecracker under the hood and it does not have GPU support, but it is in the roadmap. We are actively tracking this feature and will add support for GPU workloads as soon as it is available.</p>"},{"location":"api/","title":"Interacting with Fireactions via API","text":"<p>Fireactions provides a REST API for interacting with the server.</p>"},{"location":"api/#authentication","title":"Authentication","text":"<p>The API requires a valid API key to be included in the <code>X-API-Key</code> header of the request. The API key can be obtained from the Fireactions server by setting the <code>api_key</code> configuration option.</p>"},{"location":"api/#endpoints","title":"Endpoints","text":""},{"location":"api/#get-a-list-of-all-configured-pools","title":"Get a list of all configured pools","text":"<p>This endpoint returns a list of all pools that have been configured on the server.</p> <pre><code>GET /api/v1/pools\n</code></pre> <p>Curl example:</p> <pre><code>curl -H \"X-API-Key: &lt;API_KEY&gt;\" http://localhost:8080/api/v1/pools\n</code></pre>"},{"location":"api/#get-the-status-of-a-pool","title":"Get the status of a pool","text":"<p>This endpoint returns details of a specific pool.</p> <pre><code>GET /api/v1/pools/:pool\n</code></pre> <p>Curl example:</p> <pre><code>curl -H \"X-API-Key: &lt;API_KEY&gt;\" http://localhost:8080/api/v1/pools/my-pool\n</code></pre>"},{"location":"api/#scale-a-pool","title":"Scale a pool","text":"<p>This endpoint scales a pool up by 1 instance.</p> <pre><code>POST /api/v1/pools/:pool/scale\n</code></pre> <p>Curl example:</p> <pre><code>curl -X POST -H \"X-API-Key: &lt;API_KEY&gt;\" http://localhost:8080/api/v1/pools/my-pool/scale\n</code></pre>"},{"location":"api/#pause-a-pool","title":"Pause a pool","text":"<p>This endpoint pauses a pool, preventing it from scaling.</p> <pre><code>POST /api/v1/pools/:pool/pause\n</code></pre> <p>Curl example:</p> <pre><code>curl -X POST -H \"X-API-Key: &lt;API_KEY&gt;\" http://localhost:8080/api/v1/pools/my-pool/pause\n</code></pre>"},{"location":"api/#resume-a-pool","title":"Resume a pool","text":"<p>This endpoint resumes a pool, allowing it to scale.</p> <pre><code>POST /api/v1/pools/:pool/resume\n</code></pre> <p>Curl example:</p> <pre><code>curl -X POST -H \"X-API-Key: &lt;API_KEY&gt;\" http://localhost:8080/api/v1/pools/my-pool/resume\n</code></pre>"},{"location":"api/#reload-the-configuration","title":"Reload the configuration","text":"<p>This endpoint reloads the configuration from disk.</p> <pre><code>POST /api/v1/reload\n</code></pre> <p>Curl example:</p> <pre><code>curl -X POST -H \"X-API-Key: &lt;API_KEY&gt;\" http://localhost:8080/api/v1/reload\n</code></pre>"},{"location":"cli/","title":"Interacting with Fireactions via CLI","text":"<p>Fireactions provides a CLI for interacting with the server.</p> <pre><code>$ fireactions --help\n\nBYOM (Bring Your Own Metal) and run self-hosted GitHub runners in ephemeral, fast and secure Firecracker based virtual machines.\n\nUsage:\n  fireactions [command]\n\nMain application commands:\n  runner      Starts the virtual machine runner. This command should be run inside the virtual machine.\n  server      Start the server\n\nPool management commands:\n  resume      Resume a paused pool, enabling it to scale up again\n  pause       Pause a pool, preventing it from scaling up\n  scale       Scale a pool to specified number of replicas\n  show        Retrieve a specific pool by name\n  list        List all pools\n\nAdditional Commands:\n  reload      Reload the server with the latest configuration (no downtime)\n\nFlags:\n  -e, --endpoint string   Endpoint to use for communicating with the Fireactions API. (default \"http://127.0.0.1:8080\")\n  -u, --username string   Username to use for authenticating with the Fireactions API.\n  -p, --password string   Password to use for authenticating with the Fireactions API.\n  -h, --help              help for fireactions\n  -v, --version           version for fireactions\n\nUse \"fireactions [command] --help\" for more information about a command.\n</code></pre>"},{"location":"cli/#authentication","title":"Authentication","text":"<p>If the Fireactions server is configured with basic authentication, user must include the username and password using the <code>--username</code> and <code>--password</code> flags.</p>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#runner","title":"<code>runner</code>","text":"<p>Starts the virtual machine runner. This command should be run inside the virtual machine.</p>"},{"location":"cli/#server","title":"<code>server</code>","text":"<p>Starts the server.</p>"},{"location":"cli/#resume-name","title":"<code>resume &lt;NAME&gt;</code>","text":"<p>Resume a paused pool, enabling it to scale up again.</p>"},{"location":"cli/#pause-name","title":"<code>pause &lt;NAME&gt;</code>","text":"<p>Pause a pool, preventing it from scaling up.</p>"},{"location":"cli/#scale-name-replicasreplicas","title":"<code>scale &lt;NAME&gt; [--replicas=&lt;REPLICAS&gt;]</code>","text":"<p>Scale a pool to specified number of replicas.</p>"},{"location":"cli/#show-name","title":"<code>show &lt;NAME&gt;</code>","text":"<p>Retrieve a specific pool by name.</p>"},{"location":"cli/#list","title":"<code>list</code>","text":"<p>List all pools.</p>"},{"location":"cli/#reload","title":"<code>reload</code>","text":"<p>Reload the server with the latest configuration (no downtime).</p>"},{"location":"examples/custom-image/","title":"Creating custom image for Firecracker VMs","text":"<p>Fireactions allows you to use custom image for Firecracker virtual machines.</p> <p>Use cases:</p> <ul> <li>Pre-installing software that is often used in the organisation.</li> <li>Using a custom OS</li> <li>Pre-configuring the VM with a specific configuration</li> </ul> <p>Fireactions base images can be found in the fireactions-images GitHub repository. You can use them as a base for your custom image. Creating a custom image is as simple as creating a Dockerfile and building it:</p> <pre><code># Use the base image\nFROM --platform=linux/amd64 ghcr.io/hostinger/fireactions-images/ubuntu22.04:v0.5.1\n\n# Install software, e.g. octopilot\nCOPY --from=ghcr.io/dailymotion-oss/octopilot:v1.6.0 /usr/local/bin/octopilot /usr/local/bin/octopilot\n</code></pre> <p>Build the image and push it to container registry:</p> <pre><code>docker build -t my-custom-image . &amp;&amp; docker push my-custom-image\n</code></pre> <p>The last step is using the custom image in Fireactions by specifying it in the configuration file. The container registry must be accessible from the Fireactions server, so make sure to configure the credentials (optional).</p>"},{"location":"examples/debugging-workflows/","title":"Debugging workflows","text":"<p>Occasionally, it may be necessary to connect to a running Fireactions VM for debugging workflow steps or inspecting the filesystem.</p> <p>tmate action provides a way to SSH into a running runner VM and have full access.</p> <p>Using it is easy - just decide which workflow step to intercept, comment out the subsequent steps, then insert the tmate action just before them:</p> <pre><code>    - name: Setup tmate session\n      uses: mxschmitt/action-tmate@v3\n</code></pre> <p>Warning</p> <p>For security purposes, it's advised to add SSH keys to your github profile and limit access to yourself:</p> <pre><code>    - name: Setup tmate session\n      uses: mxschmitt/action-tmate@v3\n      with:\n        limit-access-to-actor: true\n</code></pre> <p>Additionally, instead of having to add/remove, or uncomment the required config, you can make the tmate step to be conditional and use user input:</p> <pre><code>on:\n  workflow_dispatch:\n    inputs:\n      debug_enabled:\n        type: boolean\n        description: 'Run the build with tmate debugging enabled (https://github.com/marketplace/actions/debugging-with-tmate)'\n        required: false\n        default: false\n</code></pre> <pre><code>    steps:\n      - name: Setup tmate session\n        uses: mxschmitt/action-tmate@v3\n        if: ${{ github.event_name == 'workflow_dispatch' &amp;&amp; inputs.debug_enabled }}\n</code></pre>"},{"location":"examples/docker-registry-mirror/","title":"Setting up a Docker registry mirror","text":"<p>Using DockerHub directly to pull images can be a pain due to rate limits. To avoid this, there's an option of setting up a custom registry mirror, or in other words a pull-through cache. </p> <p>This way, you can pull images from the mirror instead of DockerHub, which can be faster and more reliable.</p> <p>To set up the Docker registry mirror, include the following Ansible role in the Ansible playbook that you've used to install Fireactions:</p> <pre><code>- role: hostinger.common.registry\n  vars:\n    registry_name: docker.io\n    registry_config: \"{{ registry_config_docker_io }}\"\n  tags:\n    - registry_docker_io\n    - registry\n</code></pre> <p>The <code>registry_config_docker_io</code> variable should be defined in the <code>group_vars/all.yaml</code> file. Here's an example of how it can look like:</p> <pre><code>registry_config_docker_io:\n  version: 0.1\n  http:\n    addr: 192.168.128.1:5003 # fireactions-br0 network\n    relativeurls: false\n    draintimeout: 60s\n  storage:\n    filesystem:\n      rootdirectory: /var/lib/registry/docker.io\n  proxy:\n    remoteurl: https://registry-1.docker.io\n  log:\n    level: info\n    formatter: text\n    accesslog:\n      disabled: false\n</code></pre> <p>Then run the Ansible playbook to apply the changes:</p> <pre><code>ansible-playbook -i &lt;inventory&gt; &lt;playbook&gt;.yml --tags registry_docker_io\n</code></pre> <p>This configuration will set up a registry mirror for <code>docker.io</code> images. The mirror will be available at <code>http://192.168.128.1:5003</code>.</p> <p>After setting up the Docker registry mirror, configure the GitHub workflow to use the mirror:</p> <pre><code>- name: Set up Docker Buildx\n  uses: docker/setup-buildx-action@v3\n  with:\n    install: true\n    driver: docker-container\n    buildkitd-flags: --config /etc/buildkit/buildkitd.toml\n    config-inline: |\n      [registry.\"docker.io\"]\n        mirrors = [\"192.168.128.1:5003\"]\n        http = true\n        insecure = true\n\n- name: Pull image\n  run: |\n    docker pull alpine:latest\n</code></pre> <p>To check if it worked, run the following command:</p> <pre><code>curl --silent http://192.168.128.1:5003/v2/_catalog\n</code></pre> <p>If the output is similar to the following, congratulations, the Docker registry mirror is set up correctly!</p> <pre><code>{\"repositories\":[\"library/alpine\",\"moby/buildkit\"]}\n</code></pre>"},{"location":"sdk/","title":"Interacting with Fireactions via SDK","text":"<p>Fireactions provides a simple SDK for interacting with the Fireactions API. You can use the SDK to get, list, pause and resume pools.</p> <p>Example usage:</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  \"github.com/hostinger/fireactions\"\n)\n\nfunc main() {\n  client = fireactions.NewClient(fireactions.WithEndpoint(os.Getenv(\"FIREACTIONS_ENDPOINT\")), fireactions.WithUsername(os.Getenv(\"FIREACTIONS_USERNAME\")), fireactions.WithPassword(os.Getenv(\"FIREACTIONS_PASSWORD\")))\n\n  pool, err := client.GetPool(\"pool-id\")\n  if err != nil {\n    log.Fatalf(\"Failed to get pool: %v\", err)\n  }\n\n  fmt.Printf(\"Pool: %+v\\n\", pool)\n}\n</code></pre> <p>For more up-to-date information, see the GoDoc documentation.</p>"},{"location":"user-guide/","title":"Intro","text":"<p>Putting it simply, Fireactions is an orchestrator for GitHub runners.</p>"},{"location":"user-guide/#why-fireactions","title":"Why Fireactions?","text":"<p>Essentially, we needed a reliable and fast way to run self-hosted GitHub runners on our own infrastructure. We wanted to have the same level of control and security as with GitHub hosted runners, but without the limitations of the hosted runners (e.g. long startup times, limited resources, etc.).</p> <p>Fireactions is designed to be a cost-effective, fast and secure solution for running self-hosted GitHub runners. It is built on top of Firecracker microVMs, which provide a lightweight and secure environment for running workloads.</p>"},{"location":"user-guide/#why-firecracker","title":"Why Firecracker?","text":"<p>Firecracker is a lightweight virtual machine monitor (VMM) that uses the Linux Kernel-based Virtual Machine (KVM) to create and manage microVMs. MicroVMs are lightweight, fast and secure virtual machines that are designed to run a single application or service.</p> <p>Compared to containers, microVMs provide a higher level of isolation and security, as each microVM runs in its own isolated environment. This makes them ideal for running untrusted workloads, such as CI/CD jobs.</p>"},{"location":"user-guide/#is-it-ready-for-production","title":"Is it ready for production?","text":"<p>Fireactions is still in the early stages of development, we are waiting for feedback from the community to improve it further. However, we are already using it fully in production and it has been working well for us so far.</p>"},{"location":"user-guide/#requirements","title":"Requirements","text":"<p>There are a few requirements to run Fireactions:</p> <ul> <li>Linux machine with KVM support. We recommend using a machine with at least 2 CPU cores and 4GB of RAM.</li> <li>GitHub organisation account with PAT or GitHub App installation token.</li> <li>Containerd</li> <li>Firecracker v1.4.1 or newer</li> </ul>"},{"location":"user-guide/#quickstart","title":"Quickstart","text":"<p>To install Fireactions, see the installation guide.</p>"},{"location":"user-guide/concepts/","title":"Concepts","text":""},{"location":"user-guide/concepts/#pool","title":"Pool","text":"<p>Pool is a group of GitHub runners that share the same labels and Firecracker virtual machine configuration. Each pool can have a minimum and maximum number of runners. Fireactions will automatically scale the number of GitHub runners to match the minimum value.</p> <p>There can be multiple pools configured, each with different configurations. For example, you can have a pool with runners that have 2 vCPUs and 2 GB of RAM, and another pool with runners that have 4 vCPUs and 4 GB of RAM, each with different labels.</p> <p>Pools can be paused via CLI, which prevents it from scaling up. This can be useful when you want to prevent new runners from being created, but you don't want to delete the existing runners.</p> <p>Pools are configured in the <code>pools</code> section of the configuration file, e.g.:</p> <pre><code>pools:\n- name: example\n  max_runners: 10\n  min_runners: 1\n  runner:\n    name: example\n    image: &lt;IMAGE&gt;:&lt;IMAGE_TAG&gt;\n    image_pull_policy: IfNotPresent\n    group_id: 1\n    organization: hostinger\n    labels:\n    - self-hosted\n    - fireactions\n  firecracker:\n    binary_path: firecracker\n    kernel_image_path: /usr/local/share/firecracker/vmlinux.bin\n    kernel_args: \"console=ttyS0 noapic reboot=k panic=1 pci=off nomodules rw\"\n    machine_config:\n      mem_size_mib: 1024\n      vcpu_count: 1\n    metadata:\n      example: example\n</code></pre> <p>This will create a pool named <code>example</code> with a maximum of 10 runners and a minimum of 1 runner. The runners will have the labels <code>self-hosted</code> and <code>fireactions</code>, and will use the specified Firecracker configuration.</p>"},{"location":"user-guide/configuration/","title":"Configuration","text":"<p>Fireactions is configured using a YAML file. The default configuration file is located at <code>/etc/fireactions/config.yaml</code>.</p> <p>You can also specify a custom configuration file using the <code>--config</code> flag when starting the Fireactions server.</p> <p>Example configuration file with all available options:</p> <pre><code>---\n#\n# The address to listen on for HTTP requests.\n#\n# Default: :8080\n#\nbind_address: 0.0.0.0:8080\n\n#\n# Enable basic authentication.\n#\n# Default: false\n#\nbasic_auth_enabled: true\n\n#\n# Map of basic authentication users. The key is the username and the value is the password. Valid only when `basic_auth_enabled` is true.\n#\n# Default: {}\n#\nbasic_auth_users:\n  user1: password1\n  user2: password2\n\n#\n# Enable debug mode.\n#\n# Default: false\n#\ndebug: false\n\n#\n# Metrics server configuration. This is used to expose Prometheus metrics on endpoint `/metrics`.\n#\nmetrics:\n  #\n  # Enable Prometheus metrics.\n  #\n  enabled: true\n\n  #\n  # The address to listen on for HTTP requests.\n  #\n  address: 127.0.0.1:8081\n\n#\n# GitHub configuration.\n#\ngithub:\n  #\n  # The GitHub App private key. This is used to authenticate with GitHub.\n  #\n  # Default: \"\"\n  #\n  app_private_key: |\n    -----BEGIN RSA PRIVATE KEY-----\n  #\n  # The GitHub App ID.\n  #\n  # Default: 0\n  app_id: 12345\n\n#\n# Pools configuration.\n#\npools:\n  #\n  # The name of the pool.\n  #\n- name: fireactions-2vcpu-2gb\n  #\n  # The maximum number of GitHub runners that can be created in the pool.\n  #\n  # Required: true\n  #\n  max_runners: 20\n  #\n  # The minimum number of GitHub runners that should be running in the pool.\n  #\n  # Required: true\n  #\n  min_runners: 10\n  #\n  # GitHub runner configuration.\n  #\n  runner:\n    #\n    # The name of the GitHub runner. This is used to identify the runner in GitHub and is suffixed with a unique identifier.\n    #\n    # Required: true\n    name: fireactions-2vcpu-2gb\n    #\n    # Container image to use for the Firecracker VM as the root device.\n    #\n    # Required: true\n    #\n    image: ghcr.io/hostinger/fireactions/runner:ubuntu-20.04-x64-2.310.2\n    #\n    # The pull policy for the container image. Can be one of: Always, IfNotPresent, Never.\n    #\n    # Required: true\n    image_pull_policy: IfNotPresent\n    #\n    # GitHub runner group ID. 1 is the default group.\n    #\n    # Required: true\n    group_id: 1\n    #\n    # Organization name.\n    #\n    # Required: true\n    #\n    organization: hostinger\n    #\n    # Labels to apply to the GitHub runner.\n    #\n    # Required: true\n    #\n    labels:\n    - self-hosted\n    - fireactions-2vcpu-2gb\n    - fireactions\n  #\n  # Firecracker configuration.\n  #\n  firecracker:\n    #\n    # The path to the Firecracker binary.\n    #\n    # Default: firecracker\n    #\n    binary_path: firecracker\n    #\n    # The path to the kernel image.\n    #\n    # Required: true\n    #\n    kernel_image_path: /var/lib/fireactions/vmlinux\n    #\n    # Kernel command line arguments.\n    #\n    # Default: \"console=ttyS0 noapic reboot=k panic=1 pci=off nomodules rw\"\n    #\n    kernel_args: \"console=ttyS0 noapic reboot=k panic=1 pci=off nomodules rw\"\n    #\n    # Firecracker machine configuration.\n    #\n    # Required: true\n    #\n    machine_config:\n      #\n      # The amount of memory in MiB.\n      #\n      # Required: true\n      #\n      mem_size_mib: 2048\n      #\n      # The number of vCPUs.\n      #\n      # Required: true\n      #\n      vcpu_count: 2\n    #\n    # Metadata to pass to the Firecracker VM via MMDS.\n    #\n    # Default: {}\n    #\n    metadata:\n      example1: value1\n      example2: value2\n\n#\n# Log level. Can be one of: debug, info, warn, error, fatal, panic, trace.\n#\n# Default: info\n#\nlog_level: debug\n</code></pre>"},{"location":"user-guide/images/","title":"Images","text":"<p>Fireactions images are OCI compliant Docker images that are used to run GitHub Actions runner in Firecracker microVM. The images are built using Docker and contain all the necessary tools and dependencies.</p> <p>Each image must contain the Fireactions binary and <code>systemd</code> service file:</p> <pre><code>[Unit]\nDescription=Fireactions\nDocumentation=https://github.com/hostinger/fireactions\nAfter=network.target\nSuccessAction=reboot\n\n[Service]\nType=simple\nUser=root\nExecStart=/usr/bin/fireactions runner --log-level=info\nRestart=on-failure\nRestartSec=5s\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>The Fireactions binary is started as a systemd service when the container is run. The <code>SuccessAction</code> option is used to reboot the microVM when the Fireactions binary exits successfully, forcing the microVM to be recreated for the next job.</p>"},{"location":"user-guide/images/#available-images","title":"Available Images","text":"<p>The following images are available in this repository:</p> Name Description OS ubuntu20.04 Full Ubuntu 20.04 image with Docker, Docker Compose, and other tools Ubuntu 20.04 ubuntu22.04 Full Ubuntu 22.04 image with Docker, Docker Compose, and other tools Ubuntu 22.04 <p>To build a custom image, see the custom image example</p>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>Ansible is an open-source automation tool that allows you to automate the deployment and configuration of software on multiple servers. It is a powerful tool that can help you manage your infrastructure more efficiently.</p> <p>It is the recommended way to install Fireactions. This guide will show you how to install Fireactions using Ansible.</p>"},{"location":"user-guide/installation/#pre-requisites","title":"Pre-requisites","text":"<p>Before you begin, make sure you have the following requirements:</p> <ul> <li>Ansible set up on local machine</li> <li>GitHub App ID and private key, see Creating GitHub Apps</li> </ul>"},{"location":"user-guide/installation/#step-1-create-an-inventory-file","title":"Step 1: Create an inventory file","text":"<pre><code># hosts.ini\n[all]\nfireactions-server-1 ansible_host=&lt;IP_ADDRESS&gt; ansible_user=&lt;SSH_USER&gt;\n</code></pre>"},{"location":"user-guide/installation/#step-2-create-an-ansible-playbook","title":"Step 2: Create an Ansible playbook","text":"<pre><code># site.yaml\n---\n- name: Install Fireactions\n  hosts:\n  - all\n  become: yes\n  - role: hostinger.fireactions.fireactions\n    vars:\n      fireactions_version: 0.2.3\n      fireactions_config:\n        bind_address: 0.0.0.0:8080\n        metrics:\n          enabled: true\n          address: 127.0.0.1:8081\n        github:\n          app_id: &lt;APP_ID&gt;\n          app_private_key: |\n            &lt;APP_PRIVATE_KEY&gt;\n        debug: true\n        pools:\n        - name: example\n          max_runners: 10\n          min_runners: 1\n          runner:\n            name: example\n            image: &lt;IMAGE&gt;:&lt;IMAGE_TAG&gt;\n            image_pull_policy: IfNotPresent\n            group_id: 1\n            organization: hostinger\n            labels:\n            - self-hosted\n            - fireactions\n          firecracker:\n            binary_path: firecracker\n            kernel_image_path: /usr/local/share/firecracker/vmlinux.bin\n            kernel_args: \"console=ttyS0 noapic reboot=k panic=1 pci=off nomodules rw\"\n            machine_config:\n              mem_size_mib: 1024\n              vcpu_count: 1\n            metadata:\n              example: example\n</code></pre> <p>The <code>fireactions_config</code> variable contains the configuration for Fireactions. You can customize the configuration to suit your needs. For more information on the available configuration options, see the configuration</p>"},{"location":"user-guide/installation/#step-3-create-a-requirements-file","title":"Step 3: Create a requirements file","text":"<pre><code># requirements.yaml\n---\ncollections:\n  - name: hostinger.fireactions\n    version: 0.1.1\n  - name: hostinger.common\n    version: 0.8.0\n</code></pre>"},{"location":"user-guide/installation/#step-4-install-the-required-ansible-collections","title":"Step 4: Install the required Ansible collections","text":"<pre><code>ansible-galaxy collection install -r requirements.yaml\n</code></pre>"},{"location":"user-guide/installation/#step-5-run-the-ansible-playbook","title":"Step 5: Run the Ansible playbook","text":"<pre><code>ansible-playbook -i hosts.ini --diff site.yaml\n</code></pre> <p>The Ansible playbook will do the following:</p> <ul> <li>Install Containerd</li> <li>Install CNI plugins (bridge, host-local, firewall, tc-redirect-tap)</li> <li>Configure CNI networking</li> <li>Install Firecracker</li> <li>Setup required sysctl settings</li> <li>Install Fireactions</li> </ul> <p>After the playbook has finished, check the status of the Fireactions service:</p> <pre><code>$ systemctl status fireactions\n\u25cf fireactions.service - Fireactions\n     Loaded: loaded (/etc/systemd/system/fireactions.service; enabled; preset: enabled)\n     Active: active (running) since Sun 2024-09-08 18:59:08 UTC; 2 days ago\n       Docs: https://github.com/hostinger/fireactions\n    Process: 3564 ExecStartPre=/usr/bin/which firecracker (code=exited, status=0/SUCCESS)\n    Process: 3566 ExecStartPre=/usr/bin/which containerd (code=exited, status=0/SUCCESS)\n   Main PID: 3571 (fireactions)\n      Tasks: 480 (limit: 618568)\n     Memory: 87.8G\n        CPU: 5d 6h 21min 36.143s\n</code></pre> <p>At this point, Fireactions should be up and running. You can now proceed to running your first build.</p>"},{"location":"user-guide/kernels/","title":"Kernels","text":"<p>Firecracker requires a kernel image to boot a microVM.</p> <p>Currently, Firecracker supports uncompressed ELF kernel images on x86_64 while on aarch64 it supports PE formatted images.</p> <p>For compatibility, it is recommended to use a kernel image that is supported by the Firecracker version you are using. For more information see the Firecracker's Kernel Support Policy</p> <p>With the default Fireactions installation, the kernel image is located in the <code>/var/lib/fireactions/kernels/&lt;VERSION&gt;/vmlinux</code> path. You can change the kernel image path by modifying the <code>kernel_image_path</code> parameter for each Pool in the Fireactions configuration file.</p> <p>The latest Firecracker kernel image can be downloaded from the Firecracker CI S3 bucket. The following script can be used to download the latest kernel image for a specific version:</p> <pre><code>#!/bin/bash\n\nlatest=$(wget \"http://spec.ccfc.min.s3.amazonaws.com/?prefix=firecracker-ci/v1.10/x86_64/vmlinux-5.10&amp;list-type=2\" -O - 2&gt;/dev/null | grep \"(?&lt;=&lt;Key&gt;)(firecracker-ci/v1.10/x86_64/vmlinux-5\\.10\\.[0-9]{3})(?=&lt;/Key&gt;)\" -o -P)\n\nwget \"https://s3.amazonaws.com/spec.ccfc.min/${latest}\"\n</code></pre> <p>We also provide our own Kernel images, customized for GitHub runners. The configuration can be found here. The kernel images can be downloaded from the following links:</p> <ul> <li>https://storage.googleapis.com/fireactions/kernels/amd64/5.10/vmlinux</li> <li>https://storage.googleapis.com/fireactions/kernels/arm64/5.10/vmlinux</li> </ul> <p>You can also build your own custom kernel image. For more information see the Firecracker documentation.</p>"},{"location":"user-guide/monitoring/","title":"Monitoring","text":"<p>Fireactions provides Prometheus metrics for monitoring.</p> <p>The metrics can be enabled by setting the <code>metrics.enabled</code> configuration option to <code>true</code>. The metrics are exposed on the <code>/metrics</code> endpoint on the address and port specified in the <code>metrics.address</code> and <code>metrics.port</code> configuration options.</p>"},{"location":"user-guide/monitoring/#metrics","title":"Metrics","text":"<p>The following metrics are available, excluding the default Prometheus metrics:</p> Metric Name Description Labels <code>fireactions_pool_current_runners_count</code> Current number of runners in a pool <code>pool</code> (the pool name) <code>fireactions_pool_max_runners_count</code> Maximum number of runners in a pool <code>pool</code> (the pool name) <code>fireactions_pool_min_runners_count</code> Minimum number of runners in a pool <code>pool</code> (the pool name) <code>fireactions_pool_scale_requests</code> Number of scale requests for a pool <code>pool</code> (the pool name) <code>fireactions_pool_scale_failures</code> Number of scale failures for a pool <code>pool</code> (the pool name) <code>fireactions_pool_scale_successes</code> Number of scale successes for a pool <code>pool</code> (the pool name) <code>fireactions_pool_status</code> Status of a pool. 0 is paused, 1 is active <code>pool</code> (the pool name) <code>fireactions_pool_total</code> Total number of pools No labels <code>fireactions_server_up</code> Whether the server is up. 0 is down, 1 is up No labels"},{"location":"user-guide/monitoring/#grafana-dashboard","title":"Grafana Dashboard","text":"<p>Example Grafana dashboard for vizualisation of Fireactions metrics:</p> <p></p>"},{"location":"user-guide/running-the-first-build/","title":"Running the first build","text":"<p>Once everything is configured and Fireactions is running, check the status of the registered GitHub runners in GitHub.</p> <p>If everything is working correctly, the GitHub runners should be marked as Idle and ready to receive jobs.</p>"},{"location":"user-guide/running-the-first-build/#creating-a-new-github-workflow","title":"Creating a new GitHub workflow","text":"<p>To create a new GitHub workflow, you need to create a new file in the <code>.github/workflows</code> directory of your repository. The file should have a <code>.yml</code> extension and contain the following content:</p> <pre><code>name: test\n\non:\n  workflow_dispatch:\n  pull_request:\n      branches:\n      - '*'\n  push:\n      branches:\n      - main\n\njobs:\n  test:\n    name: test\n    runs-on: fireactions-example # The label(s) of the Fireactions pool\n    steps:\n    - name: Example\n      run: |\n        echo \"Hello, world!\"\n</code></pre> <p>This workflow will run on every push to the <code>main</code> branch, every pull request, and every manual trigger. The job will run on the <code>fireactions-example</code> pool, which is the label of the pool that you have created in the previous steps, while configuring Fireactions</p>"},{"location":"user-guide/running-the-first-build/#triggering-the-workflow","title":"Triggering the workflow","text":"<p>To trigger the workflow, you can push a new commit to the <code>main</code> branch, create a new pull request, or manually trigger the workflow from the GitHub Actions UI.</p> <p>The workflow job will be picked up by the GitHub runner and executed on the Fireactions pool that you have configured.</p>"},{"location":"user-guide/support-matrix/","title":"Support Matrix","text":"<p>This document provides a matrix of software components versions that are supported and have been tested with Fireactions.</p> v0.2.5 Firecracker v1.4.1 Containerd v1.7.0 CNI Plugins v1.6.0 <p>To ensure compatibility, it is recommended to use the versions listed above.</p>"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting","text":""},{"location":"user-guide/troubleshooting/#how-to-access-the-virtual-machine-of-github-runner","title":"How to access the virtual machine of GitHub runner?","text":"<p>To access the virtual machine, the ID of the virtual machine must be known. The ID can be found in GitHub Actions logs. Once the ID is known, the virtual machine can be accessed by finding the network namespace:</p> <pre><code>ip netns ls | grep e520c86a3ce850b055ed8f8e\nfireactions-bnk-c8-m16-e520c86a3ce850b055ed8f8e (id: 3)\n</code></pre> <p>Then, find the IP address of the virtual machine:</p> <pre><code>ip netns exec fireactions-bnk-c8-m16-e520c86a3ce850b055ed8f8e ip a\n1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n2: eth0@if20202: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether ea:32:bb:c6:49:0a brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 192.168.129.59/23 brd 192.168.129.255 scope global eth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::e832:bbff:fec6:490a/64 scope link\n       valid_lft forever preferred_lft forever\n3: tap0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether b6:cd:19:ae:29:b7 brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::b4cd:19ff:feae:29b7/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> <p>In this case, the assigned IP address is <code>192.168.129.59</code>. The virtual machine can be accessed using SSH:</p> <pre><code>ssh -l root 192.168.129.59\n</code></pre> <p>The default password is <code>fireactions</code>. This can be changed by creating a custom image. Once logged in, the virtual machine can be managed as a regular Linux machine. Inside you will find <code>fireactions</code> service logs:</p> <pre><code>root@localhost:~# systemctl status fireactions\n\u25cf fireactions.service - Fireactions\n     Loaded: loaded (/etc/systemd/system/fireactions.service; enabled; vendor preset: enabled)\n     Active: active (running) since Fri 2024-09-27 14:54:48 UTC; 2 weeks 5 days ago\n&lt;...&gt;\n</code></pre>"},{"location":"user-guide/troubleshooting/#containerd-creating-snapshot-snapshotter-not-loaded-devmapper-invalid-argument","title":"containerd: creating snapshot: snapshotter not loaded: devmapper: invalid argument","text":"<p>If the following error is found in the logs:</p> <pre><code>Nov 10 19:01:47 eu-lt-sng3-node3 fireactions[14729]: 2024-11-10 19:01:47 ERR pool.go:125 &gt; Failed to scale pool error=\"containerd: creating snapshot: snapshotter not loaded: devmapper: invalid argument\" pool=fireactions-2vcpu-2gb\n</code></pre> <p>This error is caused by the <code>devmapper</code> snapshotter not being loaded. To fix this, the <code>devmapper</code> snapshotter must be loaded. This can be done by adding the following line to the <code>containerd</code> configuration file:</p> <pre><code>tee /etc/containerd/config.toml &lt;&lt;EOF\n[plugins]\n  [plugins.\"io.containerd.snapshotter.v1.devmapper\"]\n    pool_name       = \"containerd-thinpool\"\n    root_path       = \"/var/lib/containerd/devmapper\"\n    base_image_size = \"30GB\"\n    discard_blocks  = true\nEOF\n\nsystemctl restart containerd\n</code></pre>"},{"location":"user-guide/troubleshooting/#containerd-creating-snapshot-prepare-failed-to-create-snapshot","title":"containerd: creating snapshot: prepare: failed to create snapshot","text":"<p>If the following error is found in the logs:</p> <pre><code>Nov 10 19:02:04 eu-lt-sng3-node3 fireactions[14729]: 2024-11-10 19:02:04 ERR pool.go:125 &gt; Failed to scale pool error=\"containerd: creating snapshot: prepare: failed to create snapshot \\\"containerd-thinpool-snap-35\\\" (dev: 35) from \\\"containerd-thinpool-snap-23\\\" (dev: 23): no data available: unknown\" pool=fireactions-2vcpu-2gb\n</code></pre> <p>The error message is not clear. This could happen when tampering with the installation. We've only been able to fix this by completely wiping Containerd namespaces and restarting the service. This is not a good solution, but it works.</p> <p>To do this, run the following commands:</p> <pre><code>systemctl stop containerd\n\nctr namespaces ls\nNAME                  LABELS\nfireactions-2vcpu-4gb\n\nctr --namespace=fireactions-2vcpu-4gb snapshots --snapshotter=devmapper ls\nKEY                                                                     PARENT                                                                  KIND\nfireactions-2vcpu-4gb-943101bc9e5079d2886dc0ec                          sha256:7bcb2dfc39edf0d70dcee6285aa9cb9d5cab4d84933c454d69bfd811a6a477b5 Active\n\nctr --namespace=fireactions-2vcpu-4gb snapshots --snapshotter=devmapper rm fireactions-2vcpu-4gb-943101bc9e5079d2886dc0ec\n\nctr --namespace=fireactions-2vcpu-4gb i ls\nREF                                                     TYPE                                                      DIGEST                                                                  SIZE      PLATFORMS               LABELS\nghcr.io/hostinger/fireactions-images/ubuntu22.04:v0.7.0 application/vnd.docker.distribution.manifest.list.v2+json sha256:c7dd9a4dd58300040a24a00c52a2035e1d428aeab95fbd81690a6bf37aeea87f 617.7 MiB linux/amd64,linux/arm64 -\n\nctr --namespace=fireactions-2vcpu-4gb i rm ghcr.io/hostinger/fireactions-images/ubuntu22.04:v0.7.0\n\nctr namespaces rm fireactions-2vcpu-4gb\n\nsystemctl start containerd\n</code></pre>"},{"location":"user-guide/upgrading/","title":"Upgrading","text":""},{"location":"user-guide/upgrading/#upgrading-the-github-runner","title":"Upgrading the GitHub runner","text":"<p>GitHub runner is a component inside the Fireactions runner image. To upgrade it, the Fireactions runner image needs to be updated. The runner image is defined in the <code>runner.image</code> variable in the <code>pools</code> configuration.</p> <p>Refer to the changelog for any breaking changes before the upgrade.</p>"},{"location":"user-guide/upgrading/#upgrading-fireactions","title":"Upgrading Fireactions","text":"<p>To upgrade Fireactions, override <code>fireactions_version</code> variable in your Ansible playbook:</p> <pre><code>fireactions_version: 0.2.3\n</code></pre> <p>Then run the Ansible playbook:</p> <pre><code>ansible-playbook -i &lt;inventory&gt; --diff --tags fireactions &lt;playbook&gt;\n</code></pre> <p>Keep in mind, that this will restart the Fireactions process and cause a short downtime to GitHub runners. It's best to schedule the upgrade during off-peak hours.</p>"}]}